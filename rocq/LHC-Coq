(*
  Formal Verification of Successive Running Sums (SRS) in Coq
  Translated from HOL4 proofs from:
  "Formal Verification of Real-Time Data Processing of the LHC Beam Loss Monitoring System"
*)

Require Import Arith Lia List.
Import ListNotations.

Definition D := nat -> nat.

Definition tap (n x : nat) : nat :=
  match n, x with
  | 0, 0 => 0         | 0, _ => 0
  | 1, 0 => 1 - 1     | 1, _ => 2 - 1
  | 2, 0 => 8 - 1     | 2, _ => 16 - 1
  | 3, 0 => 32 - 1    | 3, _ => 128 - 1
  | 4, 0 => 32 - 1    | 4, _ => 256 - 1
  | 5, 0 => 16 - 1    | 5, _ => 64 - 1
  | 6, 0 => 32 - 1    | 6, _ => 128 - 1
  | _, _ => 0
  end.

Definition input (n : nat) : (nat * nat) :=
  match n with
  | 0 => (0, 0)
  | 1 => (0, 0) | 2 => (0, 0) | 3 => (1, 1)
  | 4 => (3, 0) | 5 => (4, 0) | 6 => (4, 1)
  | _ => (n - 1, 0)
  end.

Fixpoint delay_aux (fuel : nat) (n : nat) : nat :=
  match fuel with
  | 0 => 1
  | S f =>
      match n with
      | 0 => 1
      | _ =>
          let '(a, b) := input n in
          delay_aux f a * S (tap a b)
      end
  end.

Definition delay (n : nat) : nat := delay_aux n n.

(* 
  Compute S (tap (fst (input 1)) (snd (input 1))).
  Compute delay 6. 
*)

Fixpoint delay_sum_aux (fuel n : nat) : nat :=
  match fuel with
  | 0 => 0
  | S f =>
      match n with
      | 0 => 0
      | _ =>
          let '(a, _) := input n in
          delay a + delay_sum_aux f a
      end
  end.

Definition delay_sum (n : nat) : nat :=
  delay_sum_aux n n.

  (* Compute delay 4.
  Compute delay 3.
  Compute delay 1.
  Compute delay 0.
  Compute delay_sum 6. *)